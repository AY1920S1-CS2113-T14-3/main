= John Doe - Project Portfolio
:site-section: AboutUs
:imagesDir: ../images
:stylesDir: ../stylesheets

== PROJECT: AddressBook - Level 3

---

== Overview

WordUp is a desktop application for English learners to manage their vocabulary during the learning process. 
The user interacts with it using a CLI, and it has a GUI created with JavaFX. It is written in Java.

== Summary of contributions

* *Major enhancement*: added the ability to schedule a list of words for revision at a date and time.
** What it does: Allows the user to set reminders at a certain date and time tagged to a list of words so that he can easily pace his learning of vocabulary using the app.
** Justification: This feature capitalises on the interactive potential of software applications. Since users are projected to store many words in the word bank over time, but might seek to revise only a selected list of words at a time, our app allows them to directly manage this revision schedule through the app, thus providing a centralised platform for vocabulary learning management.
** Highlights: To improve usability, the setting up of a study reminder is done in stages instead of having the user enter a long list of words along with the command as such: 'schedule w/word1 w/word2 w/word3 [...] 28/10/2019 2359'. Rather, to set up a reminder, the user simply enters one word 'schedule' and will be prompted subsequently by the Ui to enter the relavant fields. As such, the user no longer has to memorise the more complicated command format and also increases the speed at which the user can set up the reminder.
To integrate this into the code, the state of the setup has to be tracked in the backend, requiring more complicated logic in the code. In addition, since a popup message is used as the reminder itself to ensure that the user can continue using the app without the reminders being flushed forward as more commands are used, a new GUI window is created when the reminder is triggered regardless of what the user is doing on the app, which is harder to implement when coupling needs to be kept minimum, thus requiring more reminder management related classes.
** Credits: me

* *Moderate enhancement*: added a check history command which allows the user to check recent words added.
** What it does: Allows the user to see the list of recently added words with the most recently added words at the top.
** Justification: This feature would prove significant for users entering a long list of words (for example, when entering a list of words from one english chapter) in one sitting. They may not be aware of every single word they have already added, and it is extremely inefficient to use the search command to check for every word (by guessing) to see if it is already in the database. By allowing the user to check the list of words in reverse order of them being added (with a user defined number of past entries allowed), they can easily refer to their list of words in a single command rather than multiple commands and guessing/ or trying to add potentially duplicate entries.
** Highlights: To account for the fact that most users would not remember how many words they have in their word bank, the feature is implemented such that if the user were to request for more words than the word bank already has, for example: in a database of only 10 words, the user requests for 15 using 'history 15', the app returns all the words in the word bank rather than throwing an exception, thus increading the flexibility of the feature in handling human errors. This therefore makes it much easier and more human friendly for our users.
** Credits: me

* *Minor enhancement*: added the ability to track the number of searches for each word.
** What it does: Allows the user to see the list of word bank words in ascending or descending order of number of queries for each word.
** Justification: This feature is targeted at statistically oriented users who want to see which words they have been searching for a lot recently and can serve as an extension for future enhancements where for example, there is a test mode in the quiz function that allows our app to specifically target words which the user most frequently searched for (indicating unfamiliarity with its meaning since the meaning had to be repeatedly queried). The search count for correct words can then be reduced to reflect a level of mastery for the word. Currently this feature allows interested users to keep a mental note of the words which they were most unfamiliar with or searched for most for some reason, or to take note of past added words which are least searched for a quick revision of the meaning of a list of words rather than querying for them specifically.
** Highlights: While it seemed straightforward to implement at first, by adding a variable tracking the number of searches to each Word object, it would require a long operating time to sort the original treemap by , particularly since we are expecting a lot of words in the word bank over time. This sorting would also have to occur everytime the user uses the search count feature, and makes the execution of the command rather inefficient. Moreover, the updating of search count for each word everytime a word is queried with the 'search command' would also cost much time.
As a treemap structure is used to keep track of just the words themselves, where the 'key' is 'String word' and the 'value' is the 'Word word', a new way to store the data efficiently and for fast retrieval is required. Hence, to save processing time of the 'search count command', a single 
** Credits: me

* *Code contributed*: [https://github.com[Functional code]] [https://github.com[Test code]] _{give links to collated code files}_

* *Other contributions*:

** Project management:
*** Managed releases `v1.3` - `v1.5rc` (3 releases) on GitHub
** Enhancements to existing features:
*** Updated the GUI color scheme (Pull requests https://github.com[#33], https://github.com[#34])
*** Wrote additional tests for existing features to increase coverage from 88% to 92% (Pull requests https://github.com[#36], https://github.com[#38])
** Documentation:
*** Did cosmetic tweaks to existing contents of the User Guide: https://github.com[#14]
** Community:
*** PRs reviewed (with non-trivial review comments): https://github.com[#12], https://github.com[#32], https://github.com[#19], https://github.com[#42]
*** Contributed to forum discussions (examples:  https://github.com[1], https://github.com[2], https://github.com[3], https://github.com[4])
*** Reported bugs and suggestions for other teams in the class (examples:  https://github.com[1], https://github.com[2], https://github.com[3])
*** Some parts of the history feature I added was adopted by several other class mates (https://github.com[1], https://github.com[2])
** Tools:
*** Integrated a third party library (Natty) to the project (https://github.com[#42])
*** Integrated a new Github plugin (CircleCI) to the team repo

_{you can add/remove categories in the list above}_

== Contributions to the User Guide


|===
|_Given below are sections I contributed to the User Guide. They showcase my ability to write documentation targeting end-users._
|===

include::../UserGuide.adoc[tag=delete]

include::../UserGuide.adoc[tag=dataencryption]

== Contributions to the Developer Guide

|===
|_Given below are sections I contributed to the Developer Guide. They showcase my ability to write technical documentation and the technical depth of my contributions to the project._
|===

include::../DeveloperGuide.adoc[tag=undoredo]

include::../DeveloperGuide.adoc[tag=dataencryption]


== PROJECT: PowerPointLabs

---

_{Optionally, you may include other projects in your portfolio.}_
